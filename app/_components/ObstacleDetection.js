// ObstacleDetection.js
import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ActivityIndicator, Vibration } from 'react-native';
import { Camera, useCameraDevices, useCameraPermission } from 'react-native-vision-camera';
import * as FileSystem from 'expo-file-system';
import * as Speech from 'expo-speech';
import * as Haptics from 'expo-haptics';

// ======================== Config ========================
// Ïô∏Î∂Ä Ï£ºÏûÖ Í∞ÄÎä• (prop, global, env ÏàúÏÑú); ngrok URL Î∞îÎÄî Îïå Ïï± Ïû¨ÎπåÎìú ÏóÜÏù¥ ÍµêÏ≤¥ Í∞ÄÎä•
const DEFAULT_WS_URL = 'wss://7971e24307c1.ngrok-free.app/ws';
const getWsUrl = (propUrl) =>
  propUrl ||
  globalThis.__OD_WS_URL__ ||
  DEFAULT_WS_URL;

const FRAME_INTERVAL = 800; // ~3fps
const SPEECH_OPTS = { language: 'ko-KR' };

const SAFE_CROSS_SEC = 8;
const CAUTION_SEC = 5;
const FORBID_SEC = 5;

// ======================== Traffic Light ========================
const TL = { DETECTING_1:-2, DETECTING_2:-1, NONE:0, GREEN_INIT:1, RED:2, GREEN_GO:3, YELLOW:4, GREEN_BLINK:5 };
const TL_LABEL = {
  [-2]:'Ïã†Ìò∏Îì± Í≤ÄÏ∂ú ÏßÑÌñâ Ï§ë', [-1]:'Ïã†Ìò∏Îì± Í≤ÄÏ∂ú ÏßÑÌñâ Ï§ë', [0]:'Ïã†Ìò∏Îì± ÏóÜÏùå', [1]:'Ï¥àÎ°ùÎ∂à Í∞êÏßÄ(ÎåÄÍ∏∞)',
  [2]:'Îπ®Í∞ÑÎ∂à(ÎåÄÍ∏∞)', [3]:'Ï¥àÎ°ùÎ∂à(Í±¥ÎÑàÎèÑ Îê®)', [4]:'ÎÖ∏ÎûÄÎ∂à(Ï†ïÏßÄ)', [5]:'Ï¥àÎ°ùÎ∂à Ï†êÎ©∏(ÎåÄÍ∏∞)',
};
const TL_COOLDOWN_MS = 2500;

// ======================== Helpers ========================
function normalizeTrafficLightState(data){
  if (typeof data?.traffic_light_state === 'number') return data.traffic_light_state;
  const f = Array.isArray(data?.special_features) ? data.special_features.find(x=>x?.type==='traffic_light') : null;
  if (!f) return null;
  if (typeof f.state === 'number') return f.state;
  const s = String(f.state ?? '').toLowerCase();
  if (s === 'red') return TL.RED;
  if (s === 'yellow' || s === 'amber') return TL.YELLOW;
  if (s.includes('blink') || s.includes('flash')) return TL.GREEN_BLINK;
  if (s === 'green_go' || s === 'green' || s === 'go') return TL.GREEN_GO;
  if (s === 'green_init' || s === 'init_green' || s === 'pending') return TL.GREEN_INIT;
  if (s === 'none') return TL.NONE;
  if (s === 'detecting' || s === '') return TL.DETECTING_1;
  return null;
}
function extractRemainingSeconds(data){
  const keys = ['traffic_light_remaining','remaining_time','remain_time','remaining','time_remaining','time_left','sec_left'];
  for (const k of keys){ const v = data?.[k]; const n = normSec(v); if (n!=null) return n; }
  const f = Array.isArray(data?.special_features) ? data.special_features.find(x=>x?.type==='traffic_light') : null;
  if (f){
    for (const k of ['remaining_seconds','remaining','remainSec','time_left','sec','ms','milliseconds']){
      const v = f?.[k]; const n = normSec(v); if (n!=null) return n;
    }
  }
  return null;
}
function normSec(v){
  if (typeof v === 'string'){
    const n = parseFloat(v); if (Number.isFinite(n)) return v.toLowerCase().includes('ms') ? Math.round(n/1000) : Math.round(n);
    return null;
  }
  if (typeof v === 'number' && Number.isFinite(v)) return v > 120 ? Math.round(v/1000) : Math.round(v);
  return null;
}
function colorByLevel(level){
  switch(level){
    case 'critical': return '#FF0000';
    case 'high': return '#FF6600';
    case 'medium': return '#FFAA00';
    case 'low': return '#00AA00';
    default: return '#00FF00';
  }
}

// ======================== Component ========================
const ObstacleDetection = ({ isNavigating, userLocation, minimal = true, autoStart = true, wsUrl: propWsUrl }) => {
  // Îã®Ïùº Ïù∏Ïä§ÌÑ¥Ïä§Îßå ÌôúÏÑ±
  const [isPrimary, setIsPrimary] = useState(false);
  useEffect(() => {
    if (!globalThis.__OD_PRIMARY__) { globalThis.__OD_PRIMARY__ = true; setIsPrimary(true); }
    return () => { if (isPrimary) delete globalThis.__OD_PRIMARY__; };
  }, [isPrimary]);

  // Camera
  const devices = useCameraDevices();
  const device = useMemo(() => (devices?.back) ? devices.back :
    (Array.isArray(devices) ? devices.find(d=>d?.position==='back') : null), [devices]);
  const { hasPermission, requestPermission } = useCameraPermission();
  const [cameraReady, setCameraReady] = useState(false);
  const cameraRef = useRef(null);

  useEffect(()=>{ if (hasPermission === false) requestPermission().catch(()=>{}); }, [hasPermission, requestPermission]);

  // Active guard
  const instanceId = useRef(Math.random().toString(36).slice(2));
  const isActive = useCallback(() => globalThis.__OD_ACTIVE__?.id === instanceId.current, []);
   useEffect(() => {
       // ‚õî primaryÍ∞Ä ÏïÑÎãàÎ©¥ activeÎ•º Í∞ÄÎ°úÏ±ÑÏßÄ ÏïäÎèÑÎ°ù Ï¶âÏãú Î∞òÌôò
       if (!isPrimary) return;

    const prev = globalThis.__OD_ACTIVE__;
    if (prev?.cleanup) { try { prev.cleanup(); } catch {} }
    const cleanup = () => {
      try { frameIntervalRef.current && clearInterval(frameIntervalRef.current); } catch {}
      frameIntervalRef.current = null;
      try { keepAliveRef.current && clearInterval(keepAliveRef.current); } catch {}
      keepAliveRef.current = null;
      try { wsRef.current?.close(); } catch {}
      wsRef.current = null;
      Speech.stop(); Vibration.cancel();
    };
    globalThis.__OD_ACTIVE__ = { id: instanceId.current, cleanup };
    console.log('[OD] became active:', instanceId.current);
    return () => {
      if (globalThis.__OD_ACTIVE__?.id === instanceId.current) delete globalThis.__OD_ACTIVE__;
      cleanup();
    };
  }, [isPrimary]);

  // State
  const [isDetecting, setIsDetecting] = useState(false);
  const [dangerLevel, setDangerLevel] = useState('safe');
  const [lastWarning, setLastWarning] = useState('');
  const [isConnected, setIsConnected] = useState(false);
  const [connectionError, setConnectionError] = useState(null);
  const [tlState, setTlState] = useState(null);
  const [tlRemain, setTlRemain] = useState(null);

  const [sentCount, setSentCount] = useState(0);
  const [recvCount, setRecvCount] = useState(0);
  const [lastFrameAt, setLastFrameAt] = useState(null);
  const [lastB64, setLastB64] = useState(0);

  // Ïû•Ïï†Î¨º/ÌäπÏàò ÌîºÏ≤ò
  const [obstacles, setObstacles] = useState([]);
  const [specials, setSpecials] = useState({ crosswalk:false, stairsUp:false, stairsDown:false });

  // Refs
  const wsRef = useRef(null);
  const wsUrlRef = useRef(getWsUrl(propWsUrl));
  const frameIntervalRef = useRef(null);
  const reconnectTimeoutRef = useRef(null);
  const keepAliveRef = useRef(null);
  const busyRef = useRef(false);
  const lastWarningTimeRef = useRef(0);
  const lastTLStateRef = useRef(null);
  const lastTLAtRef = useRef(0);
  const reconnectAttemptRef = useRef(0);

  // ===== TL ÏïàÎÇ¥ =====
  const announceTrafficLight = useCallback((state, remainSec) => {
    const now = Date.now();
    if (lastTLStateRef.current === state && (now - lastTLAtRef.current) < TL_COOLDOWN_MS) return;
    lastTLStateRef.current = state; lastTLAtRef.current = now;

    if (state === TL.RED){
      Speech.speak('Îπ®Í∞ÑÎ∂àÏûÖÎãàÎã§. Í±¥ÎÑàÏßÄ ÎßàÏÑ∏Ïöî.', SPEECH_OPTS);
      Vibration.vibrate([0,400,150,400]); return;
    }
    if (state === TL.YELLOW || state === TL.GREEN_BLINK){
      Speech.speak('Ïã†Ìò∏Í∞Ä Í≥ß Î∞îÎÄùÎãàÎã§. ÏßÑÏûÖÌïòÏßÄ ÎßêÍ≥† Îã§Ïùå Ïã†Ìò∏Î•º Í∏∞Îã§Î¶¨ÏÑ∏Ïöî.', SPEECH_OPTS);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
      Vibration.vibrate([0,300,120,300]); return;
    }
    if (state === TL.GREEN_INIT){
      Speech.speak('Ï¥àÎ°ùÎ∂àÏù¥ Í∞êÏßÄÎêòÏóàÏßÄÎßå, Ïû†ÏãúÎßå Í∏∞Îã§Î†§ Ï£ºÏÑ∏Ïöî.', SPEECH_OPTS);
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light); return;
    }
    if (state === TL.GREEN_GO){
      if (typeof remainSec === 'number'){
        if (remainSec <= FORBID_SEC){
          Speech.speak('Ï¥àÎ°ùÎ∂àÏù¥ÏßÄÎßå ÏãúÍ∞ÑÏù¥ Í±∞Ïùò ÏóÜÏäµÎãàÎã§. ÏßÑÏûÖÌïòÏßÄ ÎßêÍ≥† Îã§Ïùå Ïã†Ìò∏Î•º Í∏∞Îã§Î¶¨ÏÑ∏Ïöî.', { ...SPEECH_OPTS, rate:1.05 });
          Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning); return;
        }
        if (remainSec < SAFE_CROSS_SEC && remainSec >= CAUTION_SEC){
          Speech.speak(`ÎÇ®ÏùÄ ÏãúÍ∞Ñ ÏïΩ ${remainSec}Ï¥à, ÏÑúÎëòÎü¨ Í±¥ÎÑàÏÑ∏Ïöî.`, { ...SPEECH_OPTS, rate:1.05 });
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium); return;
        }
      }
      Speech.speak('Ï¥àÎ°ùÎ∂àÏûÖÎãàÎã§. ÏßÄÍ∏à Í±¥ÎÑàÏÑ∏Ïöî.', { ...SPEECH_OPTS, rate:1.05, pitch:1.02 });
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success); return;
    }
    if (state === TL.DETECTING_1 || state === TL.DETECTING_2){
      Speech.speak('Ïã†Ìò∏Îì±ÏùÑ Ïù∏Ïãù Ï§ëÏûÖÎãàÎã§.', SPEECH_OPTS);
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    }
  }, []);

  // ===== Detection result =====
  const handleDetectionResult = useCallback((data) => {
    if (data?.error){ console.error('üß™ Í∞êÏßÄ Ïò§Î•ò:', data.error); return; }

    setDangerLevel(data?.danger_level || 'safe');

    // Ïû•Ïï†Î¨º Î™©Î°ù
    const obs = Array.isArray(data?.obstacles) ? data.obstacles : [];
    setObstacles(obs);

    // Ïã†Ìò∏Îì±
    const s = normalizeTrafficLightState(data);
    const r = extractRemainingSeconds(data);
    if (s !== null && s !== undefined){
      setTlState(s); setTlRemain(typeof r === 'number' ? r : null);
      announceTrafficLight(s, typeof r === 'number' ? r : null);
    }

    // ÌäπÏàò ÌîºÏ≤ò
    const feats = Array.isArray(data?.special_features) ? data.special_features : [];
    const flags = {
      crosswalk: !!feats.find(f => f?.type === 'crosswalk'),
      stairsUp:  !!feats.find(f => f?.type === 'stairs_up'),
      stairsDown:!!feats.find(f => f?.type === 'stairs_down'),
    };
    setSpecials(flags);

    // ÌñÖÌã±/ÏßÑÎèô
    if (data?.danger_level === 'critical'){
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
      Vibration.vibrate([0,300,100,300,100,300]);
    } else if (data?.danger_level === 'high'){
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      Vibration.vibrate([0,200,100,200,100,200]);
    } else if (data?.danger_level === 'medium'){
      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
      Vibration.vibrate([0,150,100,150]);
    }

    if (flags.stairsUp) {
      try { Speech.speak('Ïò§Î•¥Îßâ Í≥ÑÎã®Ïù¥ ÏûàÏäµÎãàÎã§.', SPEECH_OPTS); } catch {}
      Vibration.vibrate([0, 200, 100, 200]);
    }
    if (flags.stairsDown) {
      try { Speech.speak('ÎÇ¥Î¶¨Îßâ Í≥ÑÎã®Ïù¥ ÏûàÏäµÎãàÎã§. Ï£ºÏùòÌïòÏÑ∏Ïöî.', SPEECH_OPTS); } catch {}
      Vibration.vibrate([0, 300, 100, 300]);
    }
    if (flags.crosswalk) {
      try { Speech.speak('Ìö°Îã®Î≥¥ÎèÑÏûÖÎãàÎã§.', SPEECH_OPTS); } catch {}
    }

    const now = Date.now();
    if (data?.priority_warning && now - lastWarningTimeRef.current > 2000){
      Speech.speak(data.priority_warning, { ...SPEECH_OPTS, rate:1.2, pitch: data.danger_level==='critical' ? 1.2 : 1.0 });
      setLastWarning(data.priority_warning);
      lastWarningTimeRef.current = now;
    }
  }, [announceTrafficLight]);

  // ===== WebSocket =====
  const scheduleReconnect = useCallback(() => {
    if (!isDetecting) return;
    const attempt = Math.min(reconnectAttemptRef.current + 1, 6);
    reconnectAttemptRef.current = attempt;
    const delay = Math.min(30000, 1000 * Math.pow(2, attempt)); // 1s,2s,4s,...cap 30s
    if (!reconnectTimeoutRef.current){
      reconnectTimeoutRef.current = setTimeout(() => {
        reconnectTimeoutRef.current = null;
        connectWebSocket();
      }, delay);
      console.log(`[ws] Ïû¨Ïó∞Í≤∞ ÏòàÏïΩ (${attempt}) ${Math.round(delay/1000)}s ÌõÑ`);
    }
  }, [isDetecting]);

  const clearReconnectTimer = useCallback(() => {
    if (reconnectTimeoutRef.current){ clearTimeout(reconnectTimeoutRef.current); reconnectTimeoutRef.current = null; }
  }, []);

  const startKeepAlive = useCallback(() => {
    if (keepAliveRef.current) return;
    keepAliveRef.current = setInterval(() => {
      try {
        if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({ t:'ping', ts: Date.now() }));
        }
      } catch {}
    }, 20000); // 20s ping
  }, []);

  const stopKeepAlive = useCallback(() => {
    if (keepAliveRef.current){ clearInterval(keepAliveRef.current); keepAliveRef.current = null; }
  }, []);

  const connectWebSocket = useCallback(() => {
    if (!isActive() || !isPrimary || !isDetecting) return;
    try{
      if (wsRef.current?.readyState === WebSocket.OPEN) return;
      const url = wsUrlRef.current = getWsUrl(propWsUrl);
      console.log('üîå WebSocket Ïó∞Í≤∞ ÏãúÎèÑ:', url);
      const ws = new WebSocket(url);
      wsRef.current = ws;

      ws.onopen = () => {
        console.log('üü¢ WebSocket Ïó∞Í≤∞ ÏÑ±Í≥µ');
        setIsConnected(true); setConnectionError(null);
        reconnectAttemptRef.current = 0;
        clearReconnectTimer();
        startKeepAlive();
        if (!minimal){
          Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
          Speech.speak('Ïû•Ïï†Î¨º Í∞êÏßÄ ÏÑúÎ≤Ñ Ïó∞Í≤∞Îê®', SPEECH_OPTS);
        }
      };
      ws.onmessage = (event) => {
        try{
          const data = JSON.parse(event.data);
          if (data?.t === 'pong') return;
          setRecvCount(c=>c+1);
          handleDetectionResult(data);
        }catch(e){ console.error('üì® Î©îÏãúÏßÄ ÌååÏã± Ïò§Î•ò:', e); }
      };
      ws.onerror = (e) => {
        const msg = e?.message || String(e);
        console.error('üî¥ WebSocket Ïò§Î•ò:', msg);
        // 101 ÎåÄÏã† 404Í∞Ä ÏôîÏùÑ Í∞ÄÎä•ÏÑ± ‚Üí URL/Í≤ΩÎ°úÍ∞Ä ÌãÄÎ†∏Í±∞ÎÇò ngrok URLÏù¥ Î∞îÎÄê Í≤ΩÏö∞
        if (/101|404|Not Found/i.test(msg)) {
          setConnectionError('ÏÑúÎ≤Ñ ÏóÖÍ∑∏Î†àÏù¥Îìú Ïã§Ìå®(Í≤ΩÎ°ú/URL ÌôïÏù∏ ÌïÑÏöî)');
        } else {
          setConnectionError('ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïò§Î•ò');
        }
      };
      ws.onclose = (ev) => {
        console.log('‚ö™ WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å', ev?.code, ev?.reason);
        setIsConnected(false);
        stopKeepAlive();
        scheduleReconnect();
      };
    }catch(e){
      console.error('üî¥ WebSocket ÏÉùÏÑ± Ïò§Î•ò:', e);
      setConnectionError('Ïó∞Í≤∞ ÏÉùÏÑ± Ïã§Ìå®');
      scheduleReconnect();
    }
  }, [isActive, isDetecting, handleDetectionResult, isPrimary, minimal, propWsUrl, scheduleReconnect, clearReconnectTimer, startKeepAlive, stopKeepAlive]);

  const disconnectWebSocket = useCallback(()=>{
    try{ wsRef.current?.close(); }catch{}
    wsRef.current = null;
    clearReconnectTimer();
    stopKeepAlive();
    setIsConnected(false);
  }, [clearReconnectTimer, stopKeepAlive]);

  // ===== Frame capture via takePhoto =====
  const captureAndSendFrame = useCallback(async ()=>{
    try{
      // Ï∫°Ï≤ò Ï†Ñ Îπ†Î•∏ Í∞ÄÎìú
      if (!isActive() || !isPrimary) return;
      if (!isDetecting) return;
      if (!cameraReady || !cameraRef.current) { console.log('[capture] camera not ready'); return; }
      if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) { console.log('[capture] ws not open'); return; }
      if (busyRef.current) return;

      busyRef.current = true;

      const photo = await cameraRef.current.takePhoto({
        qualityPrioritization: 'speed',
        flash: 'off',
        enableShutterSound: false,
        skipMetadata: true,
      });

      const uri = photo?.path?.startsWith('file://') ? photo.path : `file://${photo?.path}`;
      const base64 = await FileSystem.readAsStringAsync(uri, { encoding: FileSystem.EncodingType.Base64 });
      if (!base64) { console.log('[capture] empty base64'); return; }

      setLastB64(base64?.length || 0);

      wsRef.current.send(JSON.stringify({
        t:'frame',
        image: base64,
        timestamp: Date.now(),
        location: userLocation,
        enable_special: true,
      }));
      setSentCount(c=>c+1);
      setLastFrameAt(Date.now());

      FileSystem.deleteAsync(uri, { idempotent:true }).catch(e=>console.log('[capture] delete fail', e));
    }catch(e){
      console.error('üì∏ ÌîÑÎ†àÏûÑ Ï∫°Ï≤ò/Ï†ÑÏÜ° Ïò§Î•ò:', e);
    }finally{
      busyRef.current = false;
    }
  }, [isActive, cameraReady, userLocation, isPrimary, isDetecting]);

  // ===== Start/Stop =====
  const startDetection = useCallback(()=>{
    if (!isActive() || !isPrimary) return;
    if (hasPermission !== true || !device) return;

    setIsDetecting(true);
    connectWebSocket();
    if (!frameIntervalRef.current){
      // Ïπ¥Î©îÎùº Ï¥àÍ∏∞Ìôî ÏãúÍ∞ÑÏùÑ Ï°∞Í∏à Ï£ºÍ≥† ÏãúÏûë
      frameIntervalRef.current = setInterval(captureAndSendFrame, FRAME_INTERVAL);
    }
    if (!minimal){
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
      Speech.speak('Ïû•Ïï†Î¨º Í∞êÏßÄÎ•º ÏãúÏûëÌï©ÎãàÎã§.', SPEECH_OPTS);
    }
  }, [isActive, isPrimary, hasPermission, device, connectWebSocket, captureAndSendFrame, minimal]);

  const stopDetection = useCallback(()=>{
    setIsDetecting(false);
    if (frameIntervalRef.current){ clearInterval(frameIntervalRef.current); frameIntervalRef.current = null; }
    disconnectWebSocket();

    setDangerLevel('safe'); setLastWarning('');
    setTlState(null); setTlRemain(null);
    setSentCount(0); setRecvCount(0); setLastFrameAt(null); setLastB64(0);
    setObstacles([]); setSpecials({ crosswalk:false, stairsUp:false, stairsDown:false });

    if (!minimal){
      Speech.speak('Ïû•Ïï†Î¨º Í∞êÏßÄÎ•º Ï§ëÏßÄÌï©ÎãàÎã§.', SPEECH_OPTS);
      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
    }
  }, [disconnectWebSocket, minimal]);

  // ===== Auto control by nav state =====
  useEffect(()=>{
    if (!isPrimary) return;
    if (hasPermission == null) return;
    if (hasPermission === true && (isNavigating || autoStart) && !isDetecting) {
      console.log('[auto] startDetection by', isNavigating ? 'navigation' : 'autoStart');
      startDetection();
    } else if ((!isNavigating && !autoStart) && isDetecting) {
      console.log('[auto] stopDetection by navigation end');
      stopDetection();
    }
  }, [isNavigating, autoStart, hasPermission, isDetecting, startDetection, stopDetection, isPrimary]);

  // ===== Cleanup =====
  useEffect(()=>()=>{ 
    if (frameIntervalRef.current){ clearInterval(frameIntervalRef.current); frameIntervalRef.current=null; }
    disconnectWebSocket(); Speech.stop(); Vibration.cancel();
  }, [disconnectWebSocket]);

  // ===== UI =====
  if (!isPrimary) return null;

  if (hasPermission !== true){
    return (
      <View style={styles.fill}>
        <View style={styles.center}>
          <Text style={styles.errorText}>Ïπ¥Î©îÎùº Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.</Text>
          <TouchableOpacity onPress={requestPermission} style={styles.permBtn}>
            <Text style={{ color:'#fff', fontWeight:'bold' }}>Í∂åÌïú ÌóàÏö©ÌïòÍ∏∞</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }
  if (!device){
    return (
      <View style={styles.fill}>
        <View style={styles.center}>
          <ActivityIndicator size="large" color="#00D8FF" />
          <Text style={styles.mono}>Ïπ¥Î©îÎùº Ïû•ÏπòÎ•º Ï∞æÎäî Ï§ë...</Text>
        </View>
      </View>
    );
  }

  return (
    <View style={styles.fill} pointerEvents="box-none">
      <Camera
        ref={cameraRef}
        style={StyleSheet.absoluteFill}
        device={device}
        isActive={true}     // ÌîÑÎ¶¨Î∑∞Îäî Ìï≠ÏÉÅ ÌëúÏãú
        photo={true}        // takePhoto ÏÇ¨Ïö©
        video={false}
        enableZoomGesture={false}
        onInitialized={()=>{ console.log('‚úÖ [VisionCamera] initialized'); setCameraReady(true); }}
        onError={(e)=>console.warn('üì∑ VisionCamera error:', e)}
      />

      {/* ÎîîÎ≤ÑÍ∑∏ Ìå®ÎÑê (minimal=falseÏùº ÎïåÎßå ÏÉÅÏÑ∏ Ï†ïÎ≥¥ ÌëúÏãú) */}
      {!minimal && (
        <View style={[styles.panel, { borderColor: colorByLevel(dangerLevel) }]}>
          <View style={styles.panelHeader}>
            <Text style={styles.panelTitle}>Ïû•Ïï†Î¨º Í∞êÏßÄ {isDetecting ? 'ÏûëÎèô Ï§ë' : 'ÎåÄÍ∏∞'}</Text>
            {isConnected && <View style={styles.connectedDot} />}
          </View>
          {connectionError && <Text style={styles.errorText}>{connectionError}</Text>}
          <Text style={styles.subtle}>sent: {sentCount}  recv: {recvCount}  lastB64: {lastB64}</Text>
          {lastFrameAt && <Text style={styles.subtle}>last frame: {new Date(lastFrameAt).toLocaleTimeString()}</Text>}
          <View style={[styles.dangerBox, { backgroundColor: colorByLevel(dangerLevel)+'30' }]}>
            <Text style={[styles.dangerText, { color: colorByLevel(dangerLevel) }]}>
              ÏúÑÌóòÎèÑ: {dangerLevel === 'critical' ? 'Í∏¥Í∏â' : dangerLevel === 'high' ? 'ÎÜíÏùå' : dangerLevel === 'medium' ? 'Ï§ëÍ∞Ñ' : dangerLevel === 'low' ? 'ÎÇÆÏùå' : 'ÏïàÏ†Ñ'}
            </Text>
            {tlState !== null && (
              <>
                <Text style={styles.trafficText}>Ïã†Ìò∏Îì± ÏÉÅÌÉú: {TL_LABEL[tlState] ?? tlState}</Text>
                {typeof tlRemain === 'number' && <Text style={styles.trafficText}>ÎÇ®ÏùÄ ÏãúÍ∞Ñ: {tlRemain}Ï¥à</Text>}
              </>
            )}
            {lastWarning ? <Text style={styles.lastText}>ÎßàÏßÄÎßâ ÏïàÎÇ¥: {lastWarning}</Text> : null}
          </View>

          {/* Ïû•Ïï†Î¨º TOP3 Î¶¨Ïä§Ìä∏ */}
          {Array.isArray(obstacles) && obstacles.length > 0 && (
            <View style={{ marginTop: 8 }}>
              <Text style={{ color:'#fff', fontWeight:'bold', marginBottom:4 }}>Í∞êÏßÄÎêú Ïû•Ïï†Î¨º: {obstacles.length}Í∞ú</Text>
              {obstacles.slice(0,3).map((o, i) => {
                const name = o?.korean_name ?? o?.name ?? 'Ïû•Ïï†Î¨º';
                const pos  = typeof o?.position === 'string' ? o.position : (o?.position?.label ?? '');
                const dist = (typeof o?.distance === 'number') ? `${Math.round(o.distance)}m` : '';
                return (
                  <Text key={i} style={{ color:'#DDD', fontSize:11 }}>
                    ‚Ä¢ {pos ? `${pos}: ` : ''}{name}{dist ? ` (${dist})` : ''}
                  </Text>
                );
              })}
            </View>
          )}

          {/* ÏàòÎèô ÏãúÏûë/Ï§ëÏßÄ Î≤ÑÌäº */}
          <TouchableOpacity
            style={[styles.btn, { backgroundColor: isDetecting ? '#FF4444' : '#44BB44' }]}
            onPress={isDetecting ? stopDetection : startDetection}
          >
            <Text style={styles.btnText}>{isDetecting ? 'Í∞êÏßÄ Ï§ëÏßÄ' : 'Í∞êÏßÄ ÏãúÏûë'}</Text>
          </TouchableOpacity>
        </View>
      )}

      {/* minimal=true Ïó¨ÎèÑ Ìï≠ÏÉÅ Î≥¥Ïù¥Îäî ÎØ∏Îãà HUD */}
      <View style={styles.tinyHud}>
        <Text style={styles.tinyHudText}>
          {isConnected ? '‚óè' : '‚óã'} s:{sentCount} r:{recvCount}
          {cameraReady ? ' cam‚úî' : ' cam‚Ä¶'}
          ws:{wsRef.current?.readyState ?? -1}
        </Text>
        <View style={{ flexDirection:'row', marginTop:4, alignItems:'center' }}>
          <Text style={styles.badge}>Ïû•Ïï†Î¨º {Math.min(obstacles?.length || 0, 99)}</Text>
          {specials.crosswalk && <Text style={styles.badge}>üö∏</Text>}
          {specials.stairsUp && <Text style={styles.badge}>‚¨ÜÔ∏è Í≥ÑÎã®</Text>}
          {specials.stairsDown && <Text style={styles.badge}>‚¨áÔ∏è Í≥ÑÎã®</Text>}
        </View>
      </View>
    </View>
  );
};

// ======================== Styles ========================
const styles = StyleSheet.create({
  fill: { flex:1, backgroundColor:'#000' },
  center: { flex:1, justifyContent:'center', alignItems:'center' },

  panel: {
    position:'absolute', top:10, left:10, right:10,
    backgroundColor:'rgba(0,0,0,0.6)', borderRadius:10, borderWidth:2, padding:10,
  },
  panelHeader: { flexDirection:'row', alignItems:'center', marginBottom:6 },
  panelTitle: { color:'#fff', fontSize:15, fontWeight:'bold', flex:1 },
  connectedDot: { width:10, height:10, borderRadius:5, backgroundColor:'#00FF00' },

  subtle: { color:'#9cf', fontSize:11, marginBottom:2 },

  dangerBox: { borderRadius:6, padding:8, marginTop:6, alignItems:'flex-start' },
  dangerText: { fontSize:13, fontWeight:'bold' },
  trafficText: { color:'#fff', marginTop:3, fontSize:12 },
  lastText: { color:'#eee', marginTop:2, fontSize:11 },

  btn: { borderRadius:18, paddingVertical:8, alignItems:'center', marginTop:8 },
  btnText: { color:'#fff', fontSize:13, fontWeight:'bold' },

  errorText: { color:'#FF6666', fontSize:13, marginVertical:4 },
  permBtn: { marginTop:10, padding:10, backgroundColor:'#007AFF', borderRadius:8 },
  mono: { color:'#fff', marginTop:8, textAlign:'center' },

  tinyHud: {
    position:'absolute', right:8, bottom:8,
    paddingHorizontal:8, paddingVertical:4, borderRadius:10,
    backgroundColor:'rgba(0,0,0,0.55)'
  },
  tinyHudText: { color:'#9cf', fontSize:10 },
  badge: {
    color:'#fff',
    fontSize:10,
    paddingHorizontal:6,
    paddingVertical:2,
    marginRight:4,
    borderRadius:8,
    backgroundColor:'rgba(255,255,255,0.1)',
  }
});

export default ObstacleDetection;
